<!doctype html><html class=no-js lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Aspose.Imaging for .NET 19.10 - Release notes</title><meta name=description content="Aspose.Imaging for .NET 19.10 - Release notes – the latest updates and fixes."><meta name=viewport content="width=device-width,minimum-scale=1"><link rel=canonical href=https://releases-qa.aspose.com/imaging/net/release-notes/2019/aspose-imaging-for-net-19-10-release-notes/><link rel=alternate hreflang=x-default href=https://releases-qa.aspose.com/imaging/net/release-notes/2019/aspose-imaging-for-net-19-10-release-notes/><meta name=robots content="noindex, nofollow"><link rel=apple-touch-icon sizes=180x180 href=/res_repo/apple-touch-icon.png><link rel=icon type=image/png href=/res_repo/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/res_repo/favicon-16x16.png sizes=16x16><link rel=mask-icon href=/res_repo/safari-pinned-tab.svg color=#0594cb><meta name=theme-color content="#ffffff"><meta property="og:title" content="Aspose.Imaging for .NET 19.10 - Release notes "><meta property="og:description" content="Aspose.Imaging for .NET 19.10 - Release notes – the latest updates and fixes."><meta property="og:type" content="article"><meta property="og:url" content="https://releases-qa.aspose.com/imaging/net/release-notes/2019/aspose-imaging-for-net-19-10-release-notes/"><meta itemprop=name content="Aspose.Imaging for .NET 19.10 - Release notes"><meta itemprop=description content="Aspose.Imaging for .NET 19.10 - Release notes – the latest updates and fixes."><meta itemprop=wordCount content="1125"><meta name=twitter:card content="summary"><meta name=twitter:title content="Aspose.Imaging for .NET 19.10 - Release notes"><meta name=twitter:description content="Aspose.Imaging for .NET 19.10 - Release notes – the latest updates and fixes."><link href=/css/bootstrap.css rel=stylesheet type=text/css preload><script src=https://releases-qa.aspose.com/res_repo/js/jquery-1.10.2.min.js></script></head><body><div id=header></div><div class=downloadpage><div class="container-fluid bcrumb1"><div id=sticky1 class=stickytopheight>&nbsp;</div><div class=container><div class=moduletable><ul id=dvBC class=breadcrumb><li><a href=/>Home</a><span class=divider></span></li><li><a href=/imaging/>Aspose.Imaging Product Family</a><span class=divider></span></li><li><a href=/imaging/net/>Aspose.Imaging for .NET</a><span class=divider></span></li><li><a href=/imaging/net/release-notes/>Release Notes</a><span class=divider></span></li><li><a href=/imaging/net/release-notes/2019/>2019</a><span class=divider></span></li><li><a href=/imaging/net/release-notes/2019/aspose-imaging-for-net-19-10-release-notes/>Aspose.Imaging for .NET 19.10 - Release notes</a><span class=divider></span></li></ul></div></div></div><div class="container-fluid content2 vpanel-left"><section role=main class="container main-container page-package-details"><div class=row><div class="col-md-3 vpanel tree-section"><p class=list-title>Browse our Products<button type=button class=treeview-toggle> <span class=sr-only>Toggle navigation</span> <span class="icon expand-icon glyphicon glyphicon-hide"></span></button></p><div id=tree class="treeview hidetree"></div></div><div class="col-md-9 lhs1 col-xs-12 mobilehide node-section package-details-main"><section role=main class="main-container page-package-details"><div class=row><div class="col-sm-9 package-details-main"><h1><strong>Aspose.Imaging for .NET 19.10 - Release notes</strong></h1><div class="tab-content body-tab-content"><div role=tabpanel class="tab-pane active" id=readme-tab><div class=readme-common><div id=readme-container><p><table><thead><tr><th style=text-align:left><strong>Key</strong></th><th style=text-align:left><strong>Summary</strong></th><th style=text-align:left><strong>Category</strong></th></tr></thead><tbody><tr><td style=text-align:left>IMAGINGNET-3419</td><td style=text-align:left><a href=https://docs.aspose.com/imaging/net/manipulating-cxm-formats/#manipulatingcxmformats-memorystrategyoptimization>Allow speed or memory optimization strategies for Cmx format</a></td><td style=text-align:left>Feature</td></tr><tr><td style=text-align:left>IMAGINGNET-3404</td><td style=text-align:left><a href=https://docs.aspose.com/imaging/net/manipulating-jpeg-images/#manipulatingjpegimages-memorystrategyoptimization>Allow speed or memory optimization strategies for Jpeg format</a></td><td style=text-align:left>Feature</td></tr><tr><td style=text-align:left>IMAGINGNET-3383</td><td style=text-align:left><a href=https://docs.aspose.com/imaging/net/drawing-images-using-graphics/#drawingimagesusinggraphics-memorystrategyoptimization>Support optimization strategy in Aspose.Imaging.Graphics</a></td><td style=text-align:left>Feature</td></tr><tr><td style=text-align:left>IMAGINGNET-2279</td><td style=text-align:left>Converting EMF to PDF file is generating pdf pages with very small view [.Net]</td><td style=text-align:left>Enhancement</td></tr><tr><td style=text-align:left>IMAGINGNET-3513</td><td style=text-align:left>SVG convert to PNG gives white PNG</td><td style=text-align:left>Enhancement</td></tr><tr><td style=text-align:left>IMAGINGNET-3200</td><td style=text-align:left>Not correct scale and position when exporting EMF to SVG without a license</td><td style=text-align:left>Enhancement</td></tr><tr><td style=text-align:left>IMAGINGNET-3276</td><td style=text-align:left>Fix PNG on TruecolorWithAlpha conversion from BMP</td><td style=text-align:left>Enhancement</td></tr><tr><td style=text-align:left>IMAGINGNET-3531</td><td style=text-align:left>Exception on loading gif image</td><td style=text-align:left>Enhancement</td></tr><tr><td style=text-align:left>IMAGINGNET-3280</td><td style=text-align:left>Usage of VectorRasterizationOptions features in Metafiles natively</td><td style=text-align:left>Enhancement</td></tr></tbody></table><h1 id=public-api-changes><strong>Public API changes:</strong></h1><p><strong>Added APIs:</strong></p><p>Method    Aspose.Imaging.FileFormats.Cmx.CmxImage.ReleaseManagedResources</p><p>Property    Aspose.Imaging.FileFormats.Wmf.WmfImage.FrameBounds</p><p><strong>h2. Removed APIs:</strong></p><h1 id=usage-examples><strong>Usage Examples:</strong></h1><p><strong>IMAGINGNET-2279 Converting EMF to PDF file is generating pdf pages with very small view [.Net]</strong></p><p><code>           </code>string baseFolder = &ldquo;D:&rdquo;;
<code>           </code>string file = &ldquo;16BE10100024023005-1-1.emf&rdquo;;
<code>           </code>string inputFileName = Path.Combine(baseFolder, file);
<code>           </code>string outputFileName = inputFileName + &ldquo;.pdf&rdquo;;
<code>           </code>using (Image image = Image.Load(inputFileName))
<code>            </code>{
<code>               </code>image.Save(outputFileName, new PdfOptions()
<code>               </code>{
<code>                   </code>VectorRasterizationOptions = new EmfRasterizationOptions() { PageSize = image.Size }
<code>               </code>});
<code>           </code>}</p><p><strong>IMAGINGNET-3513 SVG convert to PNG gives white PNG</strong></p><p>using (Image image = Image.Load(&ldquo;test2.svg&rdquo;)) {
<code> </code>image.Save(&ldquo;test2.png&rdquo;, new PngOptions());
}</p><p><strong>IMAGINGNET-3200 Not correct scale and position when exporting EMF to SVG without a license</strong></p><p><code>           </code>string[] files = new[] { &ldquo;TestEmfPlusPathLines&rdquo;, &ldquo;TestEmfPlusPens&rdquo;, &ldquo;TestEmfPolyline&rdquo; };
<code>           </code>string baseFolder = Path.Combine(&ldquo;D:&rdquo;,&ldquo;emf&rdquo;);
<code>           </code>foreach (var fileName in files)
<code>            </code>{
<code>               </code>string inputFileName = Path.Combine(baseFolder, fileName + &ldquo;.emf&rdquo;);
<code>               </code>string outFileName = Path.Combine(baseFolder, fileName + &ldquo;.svg&rdquo;);
<code>               </code>Size size;
<code>               </code>using (Image image = Image.Load(inputFileName))
<code>               </code>{
<code>                   </code>EmfRasterizationOptions emfRasterization = new EmfRasterizationOptions
<code>                   </code>{
<code>                       </code>BackgroundColor = Color.WhiteSmoke,
<code>                       </code>PageWidth = image.Width,
<code>                       </code>PageHeight = image.Height,
<code>                    </code>};</p><p><code>                   </code>size = image.Size;
<code>                   </code>image.Save(outFileName, new SvgOptions() { VectorRasterizationOptions = emfRasterization });
<code>               </code>}</p><p><code>               </code>using (Image image = Image.Load(outFileName))
<code>                </code>{
<code>                   </code>Assert.AreEqual(size, image.Size);
<code>                </code>}
<code>           </code>}</p><p><strong>IMAGINGNET-3276 Fix PNG on TruecolorWithAlpha conversion from BMP</strong></p><p>string dir = &ldquo;c:\aspose.imaging.net\IMAGINGNET\3276\&rdquo;;</p><p>using (Image image = Image.Load(dir + &ldquo;test.bmp&rdquo;))
{
<code>   </code>RasterImage rasterImage = (RasterImage)image;
<code>   </code>Color[] colors = rasterImage.LoadPixels(image.Bounds);
<code>   </code>int numberOfFullyTransparentPixels = 0;
<code>   </code>int totalNumberOfPixels = image.Width * image.Height;
<code>   </code>foreach (Color c in colors)
<code>    </code>{
<code>       </code>if (c.A == 0)
<code>        </code>{
<code>           </code>numberOfFullyTransparentPixels++;
<code>        </code>}
<code>    </code>}</p><p><code>   </code>// All pixels are fully opaque.
<code>   </code>Assert.AreEqual(0, numberOfFullyTransparentPixels);</p><p><code>   </code>PngOptions options = new PngOptions() { ColorType = Aspose.Imaging.FileFormats.Png.PngColorType.TruecolorWithAlpha };
<code>   </code>image.Save(dir + &ldquo;test.bmp.png&rdquo;, options);
}</p><p><strong>IMAGINGNET-3383 Support optimization strategy in Aspose.Imaging.Graphics</strong></p><p>const int ImageSize = 2000;
ImageOptionsBase createOptions = new PngOptions();
createOptions.Source = new FileCreateSource(this.GetFileInOutputFolder(&ldquo;temporary.png&rdquo;));
createOptions.BufferSizeHint = 30; // Memory limit is 30 Mb
using (Image image = Image.Create(createOptions, ImageSize, ImageSize)) {
Graphics graphics = new Graphics(image);
// You can use any graphic operations here, all of them will be performed within the established memory limit
// For example:
<code>   </code>graphics.Clear(Color.LightSkyBlue);
<code>   </code>graphics.DrawLine(new Pen(Color.Red, 3f), 0, 0, image.Width, image.Height);</p><p>}</p><p>// A large number of graphic operations are also supported:
const int OperationAreaSize = 10;
createOptions = new PngOptions();
createOptions.Source = new FileCreateSource(this.GetFileInOutputFolder(&ldquo;temporary.png&rdquo;));
createOptions.BufferSizeHint = 30; // Memory limit is 30 Mb
using (Image image = Image.Create(createOptions, ImageSize, ImageSize)) {
Graphics graphics = new Graphics(image);
graphics.BeginUpdate();
<code>   </code>graphics.Clear(Color.LightSkyBlue);
int x, y;
<code>   </code>for (int column = 0; column * OperationAreaSize &lt; ImageSize; column++)
<code>    </code>{
<code>       </code>for (int row = 0; row * OperationAreaSize &lt; ImageSize; row++)
<code>        </code>{
<code>           </code>operations++;</p><p><code>           </code>x = column * OperationAreaSize;
<code>           </code>y = row * OperationAreaSize;</p><p><code>           </code>bool reversed = (column + row) % 2 != 0;
<code>           </code>if (reversed)
<code>            </code>{
<code>               </code>graphics.DrawLine(
<code>                   </code>new Pen(Color.Red),
<code>                   </code>x + OperationAreaSize - 2,
<code>                   </code>y,
<code>                   </code>x,
<code>                   </code>y + OperationAreaSize);
<code>            </code>}
<code>           </code>else
<code>            </code>{
<code>               </code>graphics.DrawLine(
<code>                   </code>new Pen(Color.Red),
<code>                   </code>x,
<code>                   </code>y,
<code>                   </code>x + OperationAreaSize - 2,
<code>                   </code>y + OperationAreaSize);
<code>            </code>}
<code>        </code>}
<code>    </code>}</p><p><code>   </code>// About 40k operations will be applied here, while they do not take up too much memory
<code>   </code>// (since they are already unloaded into the external file, and will be loaded from there one at a time)
<code>   </code>graphics.EndUpdate();
}</p><p><strong>IMAGINGNET-3419 Allow speed or memory optimization strategies for Cmx format</strong></p><p>// Setting a memory limit of 10 megabytes for target loaded image
using (Image image = Image.Load(&ldquo;example.cmx&rdquo;, new LoadOptions() { BufferSizeHint = 10 }))
{
<code>   </code>image.Save(
<code>       </code>&ldquo;output.png&rdquo;,
<code>       </code>new PngOptions()
<code>            </code>{
<code>               </code>VectorRasterizationOptions =
<code>                   </code>new CmxRasterizationOptions { TextRenderingHint = TextRenderingHint.SingleBitPerPixel, SmoothingMode = SmoothingMode.AntiAlias, Positioning = PositioningTypes.DefinedByDocument}
<code>            </code>});
}</p><p><strong>IMAGINGNET-3404 Allow speed or memory optimization strategies for Jpeg format</strong></p><p>// Setting a memory limit of 50 megabytes for target loaded image
using (Image image = Image.Load(&ldquo;inputFile.jpg&rdquo;, new LoadOptions() { BufferSizeHint = 50 })) {
image.Save(&ldquo;outputFile_Baseline.jpg&rdquo;, new JpegOptions { CompressionType = JpegCompressionMode.Baseline, Quality = 100 });
image.Save(&ldquo;outputFile_Progressive.jpg&rdquo;, new JpegOptions { CompressionType = JpegCompressionMode.Progressive });
image.Save(&ldquo;outputFile_Lossless.jpg&rdquo;, new JpegOptions
<code>                                                  </code>{
<code>                                                     </code>ColorType = JpegCompressionColorMode.YCbCr,
<code>                                                     </code>CompressionType = JpegCompressionMode.Lossless,
<code>                                                     </code>BitsPerChannel = 4
<code>                                                  </code>});
image.Save(&ldquo;outputFile_JpegLs.jpg&rdquo;, new JpegOptions
<code>                                                  </code>{
<code>                                                     </code>ColorType = JpegCompressionColorMode.YCbCr,
<code>                                                     </code>CompressionType = JpegCompressionMode.JpegLs,
<code>                                                     </code>JpegLsInterleaveMode = JpegLsInterleaveMode.None,
<code>                                                     </code>JpegLsAllowedLossyError = 3,
<code>                                                     </code>JpegLsPreset = null
<code>                                                  </code>});
}</p><p>// Setting a memory limit of 50 megabytes for target created image
ImageOptionsBase createOptions = new JpegOptions { CompressionType = JpegCompressionMode.Progressive };
createOptions.BufferSizeHint = 50;
createOptions.Source = new FileCreateSource(&ldquo;createdFile.jpg&rdquo;, false);
using (var image = Image.Create(createOptions, 1000, 1000)) {
image.Save(); // save to same location
}</p><p><strong>IMAGINGNET-3531 Exception on loading gif image</strong></p><p>using (Image image = Image.Load(&ldquo;iamge.gif&rdquo;)) {
<code> </code>image.Save(&ldquo;image.png&rdquo;, new PngOptions());
}</p><p><strong>IMAGINGNET-3280 Usage of VectorRasterizationOptions features in Metafiles natively</strong></p><p>\1. Add border
input files: attachment:image1.emf, attachment:image2.wmf
output files: attachment:result_image1.emf, attachment:result_image2.wmf
~~~ csharp
<code>            </code>string baseFolder = &ldquo;D:&rdquo;;                        
<code>           </code>int borderLeft = 50;
<code>           </code>int borderTop = 50;
<code>           </code>int borderRight = 50;
<code>           </code>int borderBottom = 50;</p><p><code>            </code>string[] files = new[] { &ldquo;image1.emf&rdquo;, &ldquo;image2.wmf&rdquo; };
<code>            </code>foreach (string fileName in files)
<code>            </code>{
<code>                </code>string inputFile = Path.Combine(baseFolder, fileName);
<code>                </code>string outputFile = Path.Combine(baseFolder, &ldquo;result_&rdquo; + fileName);
<code>                </code>using (MetaImage image = (MetaImage)Image.Load(inputFile))
<code>                </code>{
<code>                    </code>image.ResizeCanvas(new Rectangle(-borderLeft, -borderTop, image.Width + borderLeft + borderRight, image.Height + borderTop + borderBottom));
<code>                    </code>image.Save(outputFile);
<code>                </code>}
<code>            </code>}
\2. Resize
<code>            </code>string baseFolder = @&ldquo;D:";
<code>            </code>string[] files = new[] {&ldquo;image3.emf&rdquo;, &ldquo;image4.wmf&rdquo;};
<code>            </code>foreach (string fileName in files)
<code>            </code>{
<code>                </code>string inputFile = Path.Combine(baseFolder, fileName);
<code>                </code>string outputFile = Path.Combine(baseFolder, &ldquo;result_&rdquo; + fileName);
<code>                </code>using (MetaImage image = (MetaImage) Image.Load(inputFile))
<code>                </code>{
<code>                    </code>image.Resize(image.Width/4, image.Height/4);
<code>                    </code>image.Save(outputFile);
<code>                </code>}
<code>            </code>}
\3. Change background
<code>            </code>string baseFolder = @&ldquo;D:";
<code>            </code>string[] files = new[] {&ldquo;image1.emf&rdquo;, &ldquo;image2.wmf&rdquo;};
<code>            </code>foreach (string fileName in files)
<code>            </code>{
<code>                </code>string inputFile = Path.Combine(baseFolder, fileName);
<code>                </code>string outputFile = Path.Combine(baseFolder, &ldquo;result_bg_&rdquo; + fileName);
<code>                </code>using (MetaImage image = (MetaImage) Image.Load(inputFile))
<code>                </code>{
<code>                    </code>FileFormat fileFormat = image.FileFormat;
<code>                   </code>if (fileFormat == FileFormat.Emf)
<code>                    </code>{
<code>                        </code>AddBackgroundRectangleEmf((EmfImage)image, Color.Blue);
<code>                    </code>}
<code>                   </code>else
<code>                    </code>{
<code>                        </code>AddBackgroundRectangleWmf((WmfImage)image, Color.Blue);
<code>                    </code>}
<code>                    </code>image.Save(outputFile);
<code>                </code>}
<code>            </code>}</p><p><code>        </code>private static void AddBackgroundRectangleEmf(EmfImage image, Color color)
<code>        </code>{
<code>            </code>image.CacheData();
<code>           </code>if (image.Records.Count &lt; 1)
<code>            </code>{
<code>               </code>return;
<code>            </code>}</p><p><code>           </code>//Set Rectangle
<code>           </code>EmfRectangle rectangle = new EmfRectangle();
<code>            </code>rectangle.Box = image.Header.EmfHeader.Bounds;</p><p><code>           </code>//Set Brush
<code>           </code>EmfCreateBrushIndirect brush = new EmfCreateBrushIndirect();
<code>            </code>brush.LogBrush = new EmfLogBrushEx();
<code>            </code>brush.LogBrush.Argb32ColorRef = color.ToArgb();</p><p><code>           </code>//Select brush
<code>           </code>EmfSelectObject selectObject = new EmfSelectObject();
<code>            </code>selectObject.ObjectHandle = 0;</p><p><code>           </code>//Remove brush
<code>           </code>EmfDeleteObject deleteObject = new EmfDeleteObject();
<code>            </code>deleteObject.ObjectHandle = 0;</p><p><code>           </code>//Add records
<code>           </code>image.Records.Insert(1, brush);
<code>            </code>image.Records.Insert(2, selectObject);
<code>            </code>image.Records.Insert(3, rectangle);
<code>            </code>image.Records.Insert(4, deleteObject);
<code>        </code>}</p><p><code>        </code>private static void AddBackgroundRectangleWmf(WmfImage image, Color color)
<code>        </code>{
<code>            </code>image.CacheData();
<code>           </code>if (image.Records.Count &lt; 1)
<code>            </code>{
<code>               </code>return;
<code>            </code>}</p><p><code>           </code>//Set Rectangle
<code>           </code>WmfRectangle rectangle = new WmfRectangle();
<code>            </code>rectangle.Rectangle = image.FrameBounds;</p><p><code>           </code>//Set Brush
<code>           </code>WmfCreateBrushInDirect brush = new WmfCreateBrushInDirect();
<code>            </code>brush.LogBrush = new EmfLogBrushEx();
<code>            </code>brush.LogBrush.Argb32ColorRef = color.ToArgb();</p><p><code>           </code>//Select brush
<code>           </code>WmfSelectObject selectObject = new WmfSelectObject(brush);</p><p><code>           </code>//Remove brush
<code>           </code>WmfDeleteObject deleteObject = new WmfDeleteObject(brush);</p><p><code>           </code>//Add records
<code>           </code>image.Records.Insert(0, brush);
<code>            </code>image.Records.Insert(1, selectObject);
<code>            </code>image.Records.Insert(2, rectangle);
<code>            </code>image.Records.Insert(3, deleteObject);
<code>        </code>}</p></p></div></div></div></div><hr></div></div></section></div></div></section></div></div><div id=dvHidden style=display:none></div><div id=footer></div><a class=backtop>&nbsp;</a><div id=DynabicMenuFooter></div><script type=text/javascript>const langarray=[]</script><script type=text/javascript>jQuery(document).ready(function(){let e=$(".nested").hide(),t=$(".treeview-animated-element");$(".treeview-animated-items-header").hover(function(){$(this).children.toggleClass("Mydiv")}),$(".treeview-animated-items-header").click(function(){return console.log("mala"),$this=$(this),console.log($this.attr("id")),$target=$this.siblings(".nested"),$pointerPlus=$this.children(".fa-plus"),$pointerMinus=$this.children(".fa-minus"),$pointerPlus.removeClass("fa-plus"),$pointerPlus.addClass("fa-minus"),$pointerMinus.removeClass("fa-minus"),$pointerMinus.addClass("fa-plus"),$this.toggleClass("open"),$target.hasClass("active")?$target.removeClass("active").slideUp():$target.addClass("active").slideDown(),!1})})</script><script>(function(e,s,o,a,t,n,i){e.ContainerizeMenuObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=s.createElement(o),i=s.getElementsByTagName(o)[0],n.async=1,n.src=a,i.parentNode.append(n)})(window,document,"script","https://menu.containerize.com/scripts/engine.min.js?v=1.0.1","aspose-en")</script><script src=https://releases-qa.aspose.com/res_repo/js/highlight.min.js></script>
<script src=https://releases-qa.aspose.com/res_repo/js/bootstrap.min.js></script>
<script src=/js/bundle.min.js></script>
<script src=/js/dynabic.treeview.js></script>
<script src=/js/treeviewmanager.js></script>
<script>hljs.highlightAll()</script><link rel=stylesheet type=text/css href=https://releases-qa.aspose.com/res_repo/css/hugocustom.css><script>$(".btn-showside .mb-5").on("click",function(){$("main .flex .dn.db-l").toggleClass("showsidebar"),$("main .flex .w-100").toggleClass("noscroll")}),$(".btn-showmenu").on("click",function(){$("nav.bg-primary-color-dark").toggleClass("showmenu")}),$(".btn-plain").on("click",function(){$("main .flex .dn.db-l").removeClass("showsidebar"),$("main .flex .dn.db-l").removeClass("showsidebar"),$("nav.bg-primary-color-dark").removeClass("showmenu")}),$(".ss-bar ul li a[data-target]").on("click",function(){$(this).find(".i.fa-angle-down").hasClass("fa-angle-up")?$(this).find("i.fa-angle-down").removeClass("fa-angle-up"):$(this).find("i.fa-angle-down").toggleClass("fa-angle-up")}),$(".btn-showside").on("click",function(){$(".ss-bar").toggleClass("showsidebar")}),$(".btn-plain").on("click",function(){$(".ss-bar").removeClass("showsidebar")})</script><script>$(document).ready(function(){$("div pre").removeAttr("style");var e,t=$(location).attr("hash");"#package-explorer"==t&&(e=document.querySelector('.nav-tabs a[href="#packageexplorer-tab"]'),e&&e.click()),$('a:has(img[alt="banner"]').click(function(){event.preventDefault();var e=document.querySelector('.nav-tabs a[href="#packageexplorer-tab"]');e&&e.click()}),$(window).scroll(function(){$(this).scrollTop()>150?$(".backtop").fadeIn():$(".backtop").fadeOut()}),$(".backtop").click(function(){return $("html, body").animate({scrollTop:0},600),!1}),$(".linkshow").on("click",function(){$(this).find("i").toggleClass("fa-minus-square"),$(".linkshowbox").toggleClass("hide")}),document.querySelector("body").addEventListener("click",function(t){if(t.target.classList.contains("searchButton")){$(".ss-bar").removeClass("showsidebar");try{var e=$("input[name=q]").val();gtag("config","UA-3109235-2",{page_path:"/search/?q="+e})}catch(e){}}if(t.target.classList.contains("fa-search")){$(".ss-bar").removeClass("showsidebar");try{e=$("input[name=q]").val(),gtag("config","UA-3109235-2",{page_path:"/search/?q="+e})}catch(e){}}},!0)})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerHTML="copy";function s(){e.innerHTML="copied!",setTimeout(()=>{e.innerHTML="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>