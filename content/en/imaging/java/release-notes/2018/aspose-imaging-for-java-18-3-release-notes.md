---
id: "aspose-imaging-for-java-18-3-release-notes"
slug: "aspose-imaging-for-java-18-3-release-notes"
linktitle: "Aspose.Imaging for Java 18.3 - Release Notes"
title: "Aspose.Imaging for Java 18.3 - Release Notes"
weight: 70
description: "Aspose.Imaging for Java 18.3 - Release Notes â€“ the latest updates and fixes."
type: "repository"
layout: "release"
hideChildren: false
toc: false
family_listing_page_title: "Aspose.Imaging for Java 18.3 - Release Notes"
menuItemWithNoContent: false
---

|**Key**|**Summary**|**Category**|
| :- | :- | :- |
|IMAGINGJAVA-934|Conversion of RGB Color System to CMYK for Tiff File Format|Feature|
|IMAGINGJAVA-933|Add support for Subscript PSD option|Feature|
|IMAGINGJAVA-932|Add support for SmallCap PSD option|Feature|
|IMAGINGJAVA-849|Support for converting CMYK PSD to CMYK TIFF|Feature|
|IMAGINGJAVA-839|Support BMP header OS22XBITMAPHEADER|Feature|
|IMAGINGJAVA-941|Concatenating TIFF images into single TIFF image is throwing exception|Enhancement|
|IMAGINGJAVA-940|Fix EMF image export without license|Enhancement|
|IMAGINGJAVA-939|ODG to JPEG not properly converted|Enhancement|
|IMAGINGJAVA-938|TIFF rotation without changing BPP|Enhancement|
|IMAGINGJAVA-937|SVG with external resources not loaded|Enhancement|
|IMAGINGJAVA-936|Exception is thrown on EMF export to WMF with text rotation|Enhancement|
|IMAGINGJAVA-935|Some public properties of ReaderDicomFileInfo class are missing in newest versions of Aspose.Imaging (starting from v16.12)|Enhancement|
|IMAGINGJAVA-915|Exception on loading image|Enhancement|
|IMAGINGJAVA-914|Image load exception is thrown on loading BMP|Enhancement|
|IMAGINGJAVA-909|DICOM file not properly converted to PNG after resize|Enhancement|
|IMAGINGJAVA-908|An exception raises while saving to TIFF format|Enhancement|
|IMAGINGJAVA-883|Conversion BMP to PNG throws an exception|Enhancement|
|IMAGINGJAVA-874|Tiff with embedded color profiles, generated by Aspose.Imaging is not compatible with Photoshop|Enhancement|
|IMAGINGJAVA-873|Saving SVG with fonts embedded or exported for Linux|Enhancement|
|IMAGINGJAVA-838|Exception on loading BMP Images|Enhancement|
|IMAGINGJAVA-783|Darker colors and color reproducibility|Enhancement|
# **Public API changes:**
## **Added APIs:**
Please see corresponding cumulative [API changes for Aspose.Imaging for .Net 18.3](/imaging/net/release-notes/2018/aspose-imaging-for-net-18-3-release-notes/) version
## **Removed APIs:**
Please see corresponding cumulative [API changes for Aspose.Imaging for .Net 18.3](/imaging/net/release-notes/2018/aspose-imaging-for-net-18-3-release-notes/) version
# **Usage examples:**
**IMAGINGJAVA-934 Conversion of RGB Color System to CMYK for Tiff File Format [Java]**
Please use the following code to convert a tiled Rgb Tiff to a striped Cmyk Tiff:

{{< highlight java >}}

 String sourceFilePath = "testTileDeflate.tif";

String outputFilePath = "testTileDeflate Cmyk.tif";

TiffOptions options = new TiffOptions(TiffExpectedFormat.TiffLzwCmyk);


Image image = Image.load(sourceFilePath);

try

{

image.save(outputFilePath, options);

}

finally

{

image.dispose();

}

{{< /highlight >}}

Please use the following code to convert a tiled RGB Tiff to a striped CMYK Tiff using specified Icc profile:

{{< highlight java >}}

 String sourceFilePath = "testTileDeflate.tif";

String outputFilePath = "testTileDeflate Cmyk Icc.tif";

String cmykProfilePath = "RSWOP.ICM";

byte[] cmykProfile;

FileInputStream f = new FileInputStream(cmykProfilePath);

try

{

cmykProfile = new byte[f.available()];

f.read(cmykProfile);

}

finally

{

f.close();

}

TiffOptions options = new TiffOptions(TiffExpectedFormat.TiffLzwCmyk);

options.setIccProfile(cmykProfile);

Image image = Image.load(sourceFilePath);

try

{

image.save(outputFilePath, options);

}

finally

{

image.dispose();

}

{{< /highlight >}}

**IMAGINGJAVA-933 Add support for Subscript PSD option [Java]**

{{< highlight java >}}

 String dir = "C:\\Temp\\";

String[] inputFiles = new String[]

{

"text",

"textReverse"

};

for (String inputFile : inputFiles)

{

Image image = Image.load(dir + inputFile + ".psd");

try

{

image.save(dir + inputFile + ".png", new PngOptions() {{ setColorType(PngColorType.TruecolorWithAlpha); }});

}

finally

{

image.dispose();

}

}

{{< /highlight >}}

**IMAGINGJAVA-932 Add support for SmallCap PSD option [Java]**

{{< highlight java >}}

 PsdImage image = (PsdImage)Image.load("smallCap.psd");

try

{

image.save("smallCap.png", new PngOptions() {{ setColorType(PngColorType.TruecolorWithAlpha); }});

}

finally

{

image.dispose();

}

{{< /highlight >}}

**IMAGINGJAVA-849 Support for converting CMYK PSD to CMYK Tiff [Java]**

{{< highlight java >}}

 public void test() throws IOException

{

String folder = "D:\\tiff\\";

//With IccProfile

this.psdToTiffCmyk(folder,true);

//Without IccProfile

this.psdToTiffCmyk(folder, false);

}

private void psdToTiffCmyk(String folder, boolean isIccProfile) throws IOException

{

String fileName = String.format("cmyk_%b.tiff", isIccProfile);

String inputFile = folder + "cmyk.psd";

String inputIccFile = folder + "JapanWebCoated.icc";

String outputFile = folder + fileName;

Image image = Image.load(inputFile);

try

{

if (isIccProfile)

{

FileInputStream f = new FileInputStream(inputIccFile);

final byte[] icc = new byte[f.available()];

f.read(icc);

f.close();

image.save(outputFile, new TiffOptions(TiffExpectedFormat.TiffLzwCmyk)

{{

setIccProfile(icc);

}});

}

else

{

image.save(outputFile, new TiffOptions(TiffExpectedFormat.TiffLzwCmyk));

}

}

finally

{

image.dispose();

}

}


{{< /highlight >}}

**IMAGINGJAVA-839 Support Bmp header OS22XBITMAPHEADER**

{{< highlight java >}}

 Image image = Image.load("test.bmp");

try

{

image.save("test.bmp.png", new PngOptions());

}

finally

{

image.dispose();

}

{{< /highlight >}}

**IMAGINGJAVA-941 Concatenating TIFF images into single TIFF image is throwing exception [Java]**

{{< highlight java >}}

 String dir = "C:\\Temp\\Errors\\";

String[] inputFiles = new String[]

{

"TWAIN-6130 A4 600 DUP 256COL_00001.tif",

"TWAIN-6130 A4 600 DUP 256COL_00002.tif",

"TWAIN-6130 A4 600 DUP 256COL_00003.tif",

};

TiffOptions createOptions = new TiffOptions(TiffExpectedFormat.Default);

createOptions.setCompression(TiffCompressions.None);

TiffFrame[] frames = new TiffFrame[inputFiles.length];

for (int i = 0; i < inputFiles.length; ++i)

{

TiffImage input = (TiffImage)Image.load(dir + inputFiles[i]);

try

{

frames[i] = TiffFrame.createFrameFrom(input.getFrames()[0], createOptions);

}

finally

{

input.dispose();

}

}

TiffImage output = new TiffImage(frames);

try

{

output.save(dir + "ConcatThreeTiffImages Out.tif");

}

finally

{

output.dispose();

}

{{< /highlight >}}

Please unpack source TIFF images and use the following code to add one of the unpacked TIFF images to another (case #2):

{{< highlight java >}}

 String dir = "C:\\Temp\\Errors\\";

String inputFilePath1 = dir + "TWAIN-6130 A4 600 DUP 256COL_00001.tif";

String inputFilePath2 = dir + "TWAIN-6130 A4 600 DUP 256COL_00002.tif";

String outputFilePath = dir + "ConcatTwoTiffImages Out.tif";

// Load the destination image

TiffImage image1 = (TiffImage)Image.load(inputFilePath1);

try

{

// Load the source image

TiffImage image2 = (TiffImage)Image.load(inputFilePath2);

try

{

// Create a copy of the active frame of the source image;

TiffFrame frame = TiffFrame.copyFrame(image2.getActiveFrame());

// Add the copied frame to the destination image;

image1.addFrame(frame);

// Save the image with changes;

image1.save(outputFilePath);

}

finally

{

image2.dispose();

}

}

finally

{

image1.dispose();

}

{{< /highlight >}}

**IMAGINGJAVA-940 Fix EMF image export without license [Java]**

{{< highlight java >}}

 // please test without license

String fileName = "Picture1.emf";

Image mf = Image.load(fileName);

try

{

EmfRasterizationOptions emfRasterizationOptions = new EmfRasterizationOptions();

emfRasterizationOptions.setBackgroundColor(Color.getBlue());

emfRasterizationOptions.setPageWidth(200);

emfRasterizationOptions.setPageHeight(200);

PngOptions pngOptions = new PngOptions();

pngOptions.setVectorRasterizationOptions(emfRasterizationOptions);

mf.save(fileName + "_IMAGINGNET-2007.png", pngOptions);

}

finally

{

mf.dispose();

}

{{< /highlight >}}

**IMAGINGJAVA-939 Odg to jpeg not properly converted [Java]**

{{< highlight java >}}

 String inputFileName = "example.odg";

String outputFileName = "example.odg.jpg";

final Image image = Image.load(inputFileName);

try

{

image.save(outputFileName, new JpegOptions() {{ setVectorRasterizationOptions(

new EmfRasterizationOptions() {{

setPageSize(Size.to_SizeF(image.getSize())); }});

}});

}

finally

{

image.dispose();

}

{{< /highlight >}}

**IMAGINGJAVA-938 Tiff rotation without changing bpp [Java]**

{{< highlight java >}}

 String dir = "C:\\Temp\\Errors\\";

PngImage image = (PngImage)Image.load(dir + "original_1bpp.png");

try

{

image.rotateFlip(RotateFlipType.Rotate90FlipNone);

image.save(dir + "original_1bpp_Rotate90FlipNone.png", image.getOriginalOptions()); // Save as 1bpp Png.

}

finally

{

image.dispose();

}

{{< /highlight >}}

**IMAGINGJAVA-937 SVG with external resources not loaded [Java]**

{{< highlight java >}}

 public void runTest()

{

String folder = "C:\\Temp\\Errors";

String inputFileName = "with-text-and-image.emf";

String inputFile = folder + File.separator + inputFileName;

String outputFile = folder + File.separator + inputFileName+".png";

ImagingNet2802ExampleClass tst = new ImagingNet2802ExampleClass(folder);

tst.test(inputFile, outputFile);

}

class SvgResourceSaver extends SvgResourceKeeperCallback

{

interface ICallback

{

Stream getResourceStream(String resourceName);

String getResourcePath(String resourceName);

String getResourceName(String extension);

}

private ICallback callback;

private final boolean embeddedResources;

private boolean exportFonts;

public boolean isEmbeddedResources()

{

return embeddedResources;

}

public boolean isExportFonts()

{

return exportFonts;

}

public void setExportFonts(boolean exportFonts)

{

this.exportFonts = exportFonts;

}

public SvgResourceSaver(ICallback callback)

{

this.callback = callback;

this.embeddedResources = false;

this.exportFonts = true;

}

public SvgResourceSaver()

{

this.embeddedResources = true;

this.exportFonts = true;

}

@Override

public void onFontResourceReady(FontStoringArgs args)

{

if (!this.exportFonts)

{

args.setFontStoreType(FontStoreType.None);

return;

}

if (this.embeddedResources)

{

args.setFontStoreType(FontStoreType.Embedded);

}

else

{

args.setFontStoreType(FontStoreType.Stream);

File f = new File(args.getSourceFontFileName());

String extension = f.getName().substring(f.getName().lastIndexOf('.'));

String resourceName = this.callback.getResourceName(extension);

args.setDisposeStream(true);

args.setDestFontStream(this.callback.getResourceStream(resourceName));

args.setFontFileUri(this.callback.getResourcePath(resourceName));

}

}

@Override

public String onImageResourceReady(byte[] imageData, int imageType, String suggestedFileName, boolean[] useEmbeddedImage)

{

if (this.embeddedResources)

return super.onImageResourceReady(imageData, imageType, suggestedFileName, useEmbeddedImage);

else

{

useEmbeddedImage[0] = false;

File f = new File(suggestedFileName);

String extension = f.getName().substring(f.getName().lastIndexOf('.'));

String resourceName = this.callback.getResourceName(extension);

Stream fs = this.callback.getResourceStream(resourceName);

try

{

fs.write(imageData, 0, imageData.length);

}

finally

{

fs.dispose();

}

return this.callback.getResourcePath(resourceName);

}

}

}

class ImagingNet2802ExampleClass implements SvgResourceSaver.ICallback

{

private int counter;

private boolean embedResources = false;

private boolean exportFonts = true;

private final String folder;

public ImagingNet2802ExampleClass(String folder)

{

this.folder = folder;

}

public void test(String inputFileName, String outputFileName)

{

SvgResourceSaver resourceSaver;

if (this.embedResources)

{

resourceSaver = new SvgResourceSaver();

}

else

{

resourceSaver = new SvgResourceSaver(this);

}

resourceSaver.setExportFonts(exportFonts);

SvgOptions svgOptions = new SvgOptions();

Image document = Image.load(inputFileName);

try

{

EmfRasterizationOptions rasterizationOptions = new EmfRasterizationOptions();

rasterizationOptions.setPageSize(Size.to_SizeF(document.getSize()));

svgOptions.setVectorRasterizationOptions(rasterizationOptions);

svgOptions.setCallback(resourceSaver);

MemoryStream svgMemoryStream = new MemoryStream();

try

{

document.save(svgMemoryStream.toOutputStream(), svgOptions);

final SvgImage image = (SvgImage)Image.load(svgMemoryStream.toInputStream());

try

{

image.save(outputFileName, new PngOptions()

{{

setVectorRasterizationOptions(new SvgRasterizationOptions()

{{

setPageSize(Size.to_SizeF(image.getSize()));

}});

}});

}

finally

{

image.dispose();

}

}

finally

{

svgMemoryStream.dispose();

}

}

finally

{

document.dispose();

}

}

public Stream getResourceStream(String resourceName)

{

String fileName = this.folder + File.separator + resourceName;

return new FileStream(fileName, FileMode.Create);

}


public String getResourcePath(String resourceName)

{

return this.folder + File.separator + resourceName;

}

public String getResourceName(String extension)

{

String fName = String.valueOf(this.counter++);

String fileName = this.folder + File.separator + fName + extension;

File f = new File(fileName);

while (f.exists())

{

fName = String.valueOf(this.counter++);

fileName = this.folder + File.separator + fName + extension;

f = new File(fileName);

}

return fName + extension;

}

}


{{< /highlight >}}

**IMAGINGJAVA-936 Exception is thrown on emf export to wmf with text rotation [Java]**

{{< highlight java >}}

 int width = 16383;

int height = 16383;

EmfRecorderGraphics2D graphics = new EmfRecorderGraphics2D(

new Rectangle(0, 0, width, height),

new Size(width, height),

new Size((int)(width * 0.01), (int)(height * 0.01)));

Font font = new Font("Times New Roman", 80, FontStyle.Regular, GraphicsUnit.Point, CharacterSet.Default);

graphics.translateTransform(15700, 8100);

graphics.rotateTransform(90); //If remove rotation - exception not thrown

graphics.drawString("R", font, Color.getRed(), 0, 0);

//this.manager.BaseDataPath = Path.Combine(this.basePath, "EmfGraphics");

//this.manager.EtalonDataPath = Path.Combine(this.manager.BaseDataPath, this.ethalonsPath);

String outFile = "IMAGINGNET_2859_out.wmf";

EmfImage image = graphics.endRecording();

try

{

OutputStream stream = new FileOutputStream(outFile);

try

{

EmfRasterizationOptions rasterizationOptions = new EmfRasterizationOptions();

WmfOptions options = new WmfOptions();

options.setVectorRasterizationOptions(rasterizationOptions);

image.save(stream, options);

}

finally

{

stream.close();

}

}

finally

{

image.dispose();

}

{{< /highlight >}}

**IMAGINGJAVA-935 Some public properties of ReaderDicomFileInfo class are missing in newest versions of Aspose.Imaging (starting from v16.12) [Java]**
File:

{{< highlight java >}}

 String file = "MonochromeSample16_2.dicom";

DicomImage image = (DicomImage)Image.load(file);

try

{

ReaderDicomFileInfo fileInfo = image.getFileInfo();

System.out.println(fileInfo.getLengthValue());

System.out.println(fileInfo.getDicomFound());

System.out.println(fileInfo.getDicomHeaderInfoByBytes().length);

System.out.println(fileInfo.getOffset());

/* Output:

131072

true

1804

1804

*/

}

finally

{

image.dispose();

}

{{< /highlight >}}

**IMAGINGJAVA-915 Exception on loading image**

{{< highlight java >}}

 Path path = Paths.get("c:/temp/2000x4000px.png");

byte[] filecontent = Files.readAllBytes(path);

Image image = Image.load(new ByteArrayInputStream(filecontent));

image.dispose();

{{< /highlight >}}

**IMAGINGJAVA-914 Image load exception is thrown on loading BMP**

{{< highlight java >}}

 BmpImage image = (BmpImage)Image.load("XING_B24.BMP");

try

{

Assert.assertTrue(image.getFileFormat ()== FileFormat.Bmp);

Assert.assertTrue(image.getWidth ()== 240);

Assert.assertTrue(image.getHeight ()== 164);

Assert.assertTrue(image.getBitmapInfoHeader().getBitmapXPelsPerMeter() == 2834);

Assert.assertTrue(image.getBitmapInfoHeader().getBitmapYPelsPerMeter() == 2834);

Assert.assertTrue(image.getBitmapInfoHeader().getBitmapCompression() == 0);

}

finally

{

image.dispose();

}

{{< /highlight >}}

**IMAGINGJAVA-909 Dicom file not properly converted to Png after resize**

{{< highlight java >}}

 Image image = Image.load("IM-0001-0001.dcm");

try

{

image.resizeHeightProportionally(300, ResizeType.LanczosResample);

image.save("IM-0001-0001.png", new PngOptions());

}

finally

{

image.dispose();

}

{{< /highlight >}}

**IMAGINGJAVA-883 Conversion BMP to PNG throws an exception**

{{< highlight java >}}

 String fileName = "decHex.bmp";

com.aspose.imaging.Image asposeImage = com.aspose.imaging.Image.load(fileName);

try

{

asposeImage.save(fileName + ".png", new PngOptions());

}

finally

{

asposeImage.dispose();

}

{{< /highlight >}}

**IMAGINGJAVA-874 Tiff with embedded color profiles, generated by Aspose.Imaging is not compatible with Photoshop**
NOTE: This code works only with license otherwise it leads to known error IMAGINGNET-2894

{{< highlight java >}}

 String embeddedIccProfilePsd = "gradation-cmyk-japan_color_2001_coated.psd";

PsdImage image = (PsdImage)Image.load(embeddedIccProfilePsd);

try

{

image.setUseRawData(true);

TiffOptions options = new TiffOptions(TiffExpectedFormat.TiffLzwCmyk);

if (image.getCmykColorProfile() != null)

{

options.setIccProfile(image.getCmykColorProfile().getStreamContainer().toBytes());

}

image.save(embeddedIccProfilePsd + ".new.tiff", options);

}

finally

{

image.dispose();

}

{{< /highlight >}}

**IMAGINGJAVA-873 Saving SVG with fonts embedded or exported for Linux [Java]**

{{< highlight java >}}

 import com.aspose.imaging.*;

import com.aspose.imaging.imageoptions.*;

import com.aspose.imaging.fileformats.svg.*;

import com.aspose.imaging.fileformats.pdf.*;

import com.aspose.imaging.system.io.*;

import java.io.File;

public class Test824

{

public static void main(String[] args)

{

SvgFontTester svgFontTester = new SvgFontTester();

svgFontTester.saveWithEmbeddedFonts();

svgFontTester.saveWithExportFonts();

}

}

class SvgFontTester

{

private static final String FontFolderName = "fonts";

private static final String OutFolderName = "Out/";

private static final String SourceFolder = "./input/";

private static String OutFolder = SourceFolder + OutFolderName;

private static String FontFolder = OutFolder + "/" + FontFolderName;

public void readFileWithEmbeddedFontsAndExportToPdf()

{

this.readAndExportToPdf("EmbeddedFonts.svg");

}

public void readFileWithExportedFontsAndExportToPdf()

{

this.readAndExportToPdf("ExportedFonts.svg");

}

public void saveWithEmbeddedFonts()

{

String[] files = new String[]

{

"exportedFonts.svg", // File with exported fonts

"embeddedFonts.svg", // File with embedded fonts

"mysvg.svg" // simple file

};

for (int i = 0; i < files.length; i++)

{

this.save(true, files[i], 0);

}

}

public void saveWithExportFonts()

{

String[] files = new String[]

{

"exportedFonts.svg", // File with exported fonts

"embeddedFonts.svg", // File with embedded fonts

"mysvg.svg" // simple file

};

int[] expectedFontsCount = new int[] {

4, 4, 1

} ;

for (int i = 0; i < files.length; i++)

{

this.save(false, files[i], expectedFontsCount[i]);

}

}

private void readAndExportToPdf(String inputFileName)

{

File f = new File(OutFolder);

if (!f.exists())

{

f.mkdir();

}

String inputFile = SourceFolder + inputFileName;

String outFile = OutFolder + "/" + inputFileName + ".pdf";

final Image image = Image.load(inputFile);

try

{

image.save(outFile,

new PdfOptions()

{{

setVectorRasterizationOptions(new SvgRasterizationOptions()

{{

setPageSize(new SizeF(image.getWidth(), image.getHeight()));

}});

}});

}

finally

{

image.dispose();

}

}

private void save(final boolean useEmbedded, String fileName, int expectedCountFonts)

{

File f = new File(OutFolder);

if (!f.exists())

{

f.mkdir();

}

String fontStoreType = useEmbedded ? "Embedded" : "Stream";

String inputFile = SourceFolder + fileName;

String outFileName = fileName + "_" + fontStoreType + ".svg";

String outputFile = OutFolder + "/" + outFileName;

Image image = Image.load(inputFile);

final String fontFolder;

try

{

final EmfRasterizationOptions emfRasterizationOptions = new EmfRasterizationOptions();

emfRasterizationOptions.setBackgroundColor(Color.getWhite());

emfRasterizationOptions.setPageWidth(image.getWidth());

emfRasterizationOptions.setPageHeight(image.getHeight());

final String testingFileName = inputFile.substring(inputFile.lastIndexOf("/")+1, inputFile.length() - 4);

fontFolder = FontFolder + "/" + testingFileName;

image.save(outputFile,

new SvgOptions()

{{

setVectorRasterizationOptions(emfRasterizationOptions);

setCallback(

new SvgCallbackFontTest(useEmbedded, fontFolder)

{{

setLink(FontFolderName +"/"+testingFileName);

}});

}});

}

finally

{

image.dispose();

}

if (!useEmbedded)

{

f = new File(fontFolder);

String[] files = f.list();

if (files.length != expectedCountFonts)

{

throw new RuntimeException(String.format(

"Expected count font files = %d, Current count font files = %d", expectedCountFonts,

files.length));

}

}

}

}

class SvgCallbackFontTest extends SvgResourceKeeperCallback

{

/**

\* The out folder

*/

private final String outFolder;

/**

\* The use embedded font

*/

private final boolean useEmbeddedFont;

/**

\* The font counter

*/

private int fontCounter = 0;

/**

\* Initializes a new instance of the {@see SvgTests.svgCallbackFontTest} class.

\* @param useEbeddedFont if set to true [use ebedded font].

\* @param outFolder The out folder.

*/

public SvgCallbackFontTest(boolean useEbeddedFont, String outFolder)

{

this.useEmbeddedFont = useEbeddedFont;

this.outFolder = outFolder;

File f = new File(outFolder);

if (f.exists())

{

File[] list = f.listFiles();

for (File it : list)

it.delete();

f.delete();

}

}

private String link;

public String getLink()

{

return link;

}

public void setLink(String link)

{

this.link = link;

}

/**

\* Called when font resource ready to be saved to storage.

\* @param args The arguments.

*/

@Override

public void onFontResourceReady(FontStoringArgs args)

{

System.out.println("Enter to onFontResourceReady");

if (this.useEmbeddedFont)

{

args.setFontStoreType(FontStoreType.Embedded);

}

else

{

args.setFontStoreType(FontStoreType.Stream);

String fontFolder = this.outFolder;

File f = new File(fontFolder);

if (!f.exists())

{

f.mkdirs();

}

String fName = args.getSourceFontFileName();

f = new File(fName);

if (!f.exists())

{

fName = String.format("font_%d.ttf", this.fontCounter++);

f = new File(fName);

}

String name = f.getName();

name = name.substring(name.indexOf('/')+1);

String fileName = fontFolder + "/" + name;

args.setDestFontStream(new FileStream(fileName, FileMode.OpenOrCreate));

args.setDisposeStream(true);

args.setFontFileUri("./" + this.getLink() + "/" + name);

}

}

}

{{< /highlight >}}

**IMAGINGJAVA-838 Exception on loading BMP Images**

{{< highlight java >}}

 Image image = Image.load("test_pattern.bmp");

try

{

long format=image.getFileFormat();

System.out.println("Format: " + FileFormat.getName(FileFormat.class, format));

}

finally

{

image.dispose();

}

{{< /highlight >}}

`Â `**IMAGINGJAVA-783 Darker colors and color reproducibility**

{{< highlight java >}}

 Â public void test783()

{

License l = new License();

l.setLicense("Aspose.Imaging.Java.lic");

String path = "C:\\Temp\\Errors\\783\\";

// Load Tiff image with embedded Icc

{

String embeddedIccProfileTiff = path + "Cmyk-CmykProfile.tif";

TiffImage image = (TiffImage) Image.load(embeddedIccProfileTiff);

try

{

// get icc by tag

TiffDataType tag = image.getActiveFrame().getFrameOptions().getTagByType(TiffTags.IccProfile);

byte[] profileStream = (byte[]) tag.getValue();

AssertProfile(profileStream);

// icc property

byte[] profileStream2 = image.getActiveFrame().getFrameOptions().getIccProfile();

// Must be the same

Compare(profileStream, profileStream2);

AssertProfile(profileStream2);

}

finally

{

image.dispose();

}

}

// Load Psd image with embedded Icc

{

String embeddedIccProfilePsd = path + "NavyExchangeCmyk.psd";

PsdImage image = (PsdImage) Image.load(embeddedIccProfilePsd);

try

{

com.aspose.imaging.system.io.MemoryStream profileStream = (com.aspose.imaging.system.io.MemoryStream)image.getCmykColorProfile().getStream();

AssertProfile(profileStream.toArray());

}

finally

{

image.dispose();

}

}

// Convert Psd image with embedded Cmyk Icc to Tiff with embedded Cmyk Icc

{

String embeddedIccProfilePsd = path + "NavyExchangeCmyk.psd";

final byte[] sourceIccData;

PsdImage image = (PsdImage) Image.load(embeddedIccProfilePsd);

try

{

TiffOptions options = new TiffOptions(TiffExpectedFormat.TiffLzwRgba);

// add Icc profile tag

sourceIccData = ((com.aspose.imaging.system.io.MemoryStream) image.getCmykColorProfile().getStream()).toArray();

TiffUndefinedType tmp = new TiffUndefinedType(TiffTags.IccProfile);

tmp.setData(sourceIccData);

options.addTag(tmp);

image.save(embeddedIccProfilePsd + "_output.tiff", options);

}

finally

{

image.dispose();

}

// verify

TiffImage image2 = (TiffImage) Image.load(embeddedIccProfilePsd + "_output.tiff");

try

{

byte[] profileStream = image2.getActiveFrame().getFrameOptions().getIccProfile();

AssertProfile(profileStream);

Assert.assertTrue(Compare(profileStream, sourceIccData));

}

finally

{

image2.dispose();

}

}

}

private void AssertProfile(byte[] profileStream)

{

msAssert.isNotNull(profileStream);

msAssert.isFalse(Compare(profileStream, IccProfileHelper.getDefaultCmykProfile()));

msAssert.isFalse(Compare(profileStream, IccProfileHelper.getDefaultRgbProfile()));

}

private boolean Compare(byte[] data1, byte[] data2)

{

if (data1.length != data2.length)

{

return false;

}

for (int i = 0; i < data2.length; i++)

{

if (data1[i] != data2[i])

{

return false;

}

}

return true;

}

static class IccProfileHelper

{

static final String CmykProfilePath = "com/aspose/imaging/internal/System/Drawing/rswop.icm";

static final String RgbProfilePath = "com/aspose/imaging/internal/System/Drawing/sRGB_v4_ICC_preference_displayclass.icc";

static byte[] getDefaultCmykProfile()

{

return getResource(CmykProfilePath);

}

static byte[] getDefaultRgbProfile()

{

return getResource(RgbProfilePath);

}

private static byte[] getResource(String resourceName)

{

InputStream stream = com.aspose.imaging.Image.class.getClassLoader().getResourceAsStream(resourceName);

if (stream == null)

throw new RuntimeException("Error loading icc profile resource");

try

{

byte[] buffer = new byte[stream.available()];

stream.read(buffer);

return buffer;

}

catch (IOException e)

{

throw new FrameworkException("Error loading icc profile resource", e);

}

}

}

{{< /highlight >}}

`Â `**IMAGINGJAVA-908 An exception raises while saving to TIFF format**

{{< highlight java >}}

 PsdImage image = (PsdImage) Image.load("ng PSD preview_CMYK.psd");

TiffOptions options = new TiffOptions(TiffExpectedFormat.TiffNoCompressionRgba);

try

{

image.save("output.tiff", options);

}

finally

{

image.dispose();

}

{{< /highlight >}}
